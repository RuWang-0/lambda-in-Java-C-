## Lambda-Java-node

<p align = right>刘佳盼 17307130113</p>

------

#### 前言

看完C++之后我们来看一下Java。

它显著增强了Java。

新的语法元素-> 表达能力提升 -> 更简洁（多行到一行） -> API（一行里调用） -> 流线化（结构）  -> 并行处理功能。

既然有这么多好处，我们就来看一下它的语法。

------

#### 语法

操作符是`->`，称为lambda操作符或箭头操作符。它的用法是箭头左边是参数，右边是lambda体，可以是一个表达式或者一个大括号括起来的代码块。参数能够传入到lambda体当中。

对于lambda表达式的用法呢，我们来看一下几个例子，来更好地理解一下。Java 7 & Java 8。

（表达式体）可以没有参数，可以类型推断或指定类型。

（块体）Java 8能够将“一块代码”赋值给一个Java变量。在块lambda中必须显式使用`return`语句来返回值，因为块lambda体代表的不是单独一个表达式。

实际应用：作为参数传递。

（参数传递）可以作为参数传递lambda表达式，同时匿名内部类也可以作为参数传递。

那么，lambda表达式看起来是对匿名内部类的一个简写，只要在编译阶段把所有的lambda表达式替换成匿名内部类就可以了。

我们就来看一下吧。

------

#### 匿名内部类

对于这个包含内部匿名类的代码，编译后会产生两个class文件，还会创建匿名内部类的对象。说明匿名内部类仍然是一个类。

再用lambda表达式替换掉这个内部匿名类，编译后只有一个class文件，这就不一样了。被封装成主类的一个私有方法。相比于匿名类，lambda表达式更像是一个匿名方法。

所以lambda表达式并不是对匿名内部类的一个简写。

------

#### 函数式接口

我们再来看一下新的概念，叫做**函数式接口**。

==函数式接口是仅包含一个抽象方法的接口，通常表示单个动作。==

Java 8 引入函数式接口有它的原因：

1. C#和C++都有，Java眼红了。

2. 代码简洁。

3. 多核友好。

对于函数式接口，一个简单的例子是标准接口`Runnable`，因为它只定义了一个方法`run()`，`run()`定义了`Runnable`的动作。然后一般是通过重载的方式调用这个接口。

==而lambda表达式本质上是用于实现由函数式接口定义的另一个方法。==

稍微解释简化过程：**public是多余的**（知道是public），**函数名Runnalbe是多余的**（接口名，变量类型），**方法名run是多余的**（只有一个动作），**返回类型void是多余的**（接口里定义了，或者编译器自己判断），**最后加上操作符"->"**，完美。

Java 8 就是通过这样的方式实现lambda表达式。那么一个lambda表达式对应一个接口？当然不是，最开始的例子就没有**自定义**接口。另外还有一个泛型机制。

lambda表达式自身不能指定类型参数。因此，lambda表达式不能是泛型，然而，与lambda表达式关联的函数式接口可以是泛型。

------

#### 变量捕获

不能修改、不能重名。

尽管放宽了对捕获值的语法限制，但仍禁止捕获可变局部变量，这样有两个原因：

其一，Java 8 语言的lambda表达式只实现了capture-by-value，也就是说它捕获的局部变量都会拷贝一份到lambda表达式的实体中，然后在lambda表达式里要变也只能变自己拷贝的那份，而无法影响外部原本的变量，所以Java语言的设计者就干脆禁止捕获可变局部变量。

其二，Java 8 可以写出并行代码。其中`forEach`是并行的，这样写的代码没有写竞争条件，让lambda体执行起来相当困难。

------

总结一下。

------

项目总结。

我们研究了$\lambda$演算还有C++和Java中的lambda表达式。