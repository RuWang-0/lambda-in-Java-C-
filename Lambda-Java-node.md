## Lambda-Java-node

<p align = right>刘佳盼 17307130113</p>

------

#### 前言

Java 8的一个大亮点是引入lambda表达式，它显著增强了Java。

首先，它们增加了新的**语法元素**，使Java语言的表达能力得以提升（更简洁，如用lambda语法来代替匿名内部类），并**流线化**（stream）了一些常用结构的实现方式。

其次，lambda表达式的加入也导致API 库中增加了新的功能，包括利用多核环境的**并行处理**功能（尤其是在处理`for-each`风格的操作时）变得更加容易，以及支持对数据执行管道操作的新的流API。

那么以上这些功能，比如并行处理和管道操作，居然与lambda表达式有关，那我们就先来看一下如何使用lambda表达式。

------

#### 语法

首先是它的语法，Java中引入了一个新的语法元素和操作符，这个操作符是`->`，称为lambda操作符或箭头操作符。它的用法是箭头左边是参数，右边是lambda体，可以是一个表达式或者一个大括号括起来的代码块。参数能够传入到lambda体当中。

如果lambda体里运行出错呢，它也能够抛出异常，和正常的异常处理机制差不多。

对于lambda表达式的用法呢，我们来看一下几个例子，来更好地理解一下。Java 7 & Java 8。

（表达式体）可以没有参数，可以类型推断或指定类型。（结果返回到哪呢，可以作为参数）

（参数传递）可以作为参数传递lambda表达式。

（块体）Java 8能够将“一块代码”赋值给一个Java变量。在块lambda中必须显式使用`return`语句来返回值，因为块lambda体代表的不是单独一个表达式。

------

#### 变量捕获

既然里面可以定义局部变量（max），那么我们想使用lambda体外部的变量呢，也是可以的。lambda表达式可以获取或设置其外层类的实例或静态变量的值，以及调用其外层类定义的方法。但是有一定的限制，不允许声明一个与外部局部变量同名的参数或者局部变量，不能在lambda表达式内部或者之后修改外部变量。不能修改，相当于只能引用标记了`final`或者隐性具有`final`语义(`effectively final`)的外部局部变量。

比如下面这个例子是正确的balabala，但是不能修改也不能重名。关于原因在后面介绍。

------

#### 匿名内部类

那么Java是如何实现lambda表达式的呢，前面提到lambda表达式可以作为参数传递，同时匿名内部类也可以作为参数传递。那么，lambda表达式看起来是对匿名内部类的一个简写，只要在编译阶段把所有的lambda表达式替换成匿名内部类就可以了。

我们就来看一下吧。

对于这个包含内部匿名类的代码，编译后会产生两个class文件，还会创建匿名内部类的对象。说明匿名内部类仍然是一个类，只是不需要程序员指定类名，编译器会自动为该类取名。

再用lambda表达式替换掉这个内部匿名类，编译后只有一个class文件，这就不一样了。被封装成主类的一个私有方法。相比于匿名类，lambda表达式更像是一个匿名方法。

然后我们再扩展一下。

所以lambda表达式并不是对匿名内部类的一个简写。

------

#### 函数式接口

我们再来看一下新的概念，叫做**函数式接口**。

==函数式接口是仅包含一个抽象方法的接口，通常表示单个动作。==

Java8引入函数式接口有它的原因：

1. **代码简洁**函数式编程写出的代码简洁且意图明确，使用*stream*接口让你从此告别*for*循环。
2. **多核友好**，Java函数式编程使得编写并行程序从未如此简单，你需要的全部就是调用一下`parallel()`方法。

对于函数式接口，一个简单的例子是标准接口`Runnable`，因为它只定义了一个方法`run()`，`run()`定义了`Runnable`的动作。然后一般是通过重载的方式调用这个接口。

而lambda表达式本质上是用于实现由函数式接口定义的另一个方法。

稍微解释简化过程：public是多余的，函数名Runnalbe是多余的（接口名），方法名run是多余的（只有一个动作），返回类型void是多余的（接口里定义了，或者编译器自己判断），最后加上操作符"->"，完美。

下面通过例子来说明如何在参数上下文中使用lambda表达式。

当目标类型上下文中出现lambda表达式时，会自动创建实现了函数式接口的一个类的实例，函数式接口声明的抽象方法的行为由lambda表达式定义。当通过目标调用该方法时，就会执行lambda表达式。因此，**lambda表达式提供了一种将代码片段转换为对象的方法。**

lambda表达式自身不能指定类型参数。因此，lambda表达式不能是泛型，然而，与lambda表达式关联的函数式接口可以是泛型。==有关Java的泛型机制，下周有个相关的报告。==

------

#### 变量捕获2

尽管放宽了对捕获值的语法限制，但仍禁止捕获可变局部变量，这样有两个原因：

其一，Java 8语言的lambda表达式只实现了capture-by-value，也就是说它捕获的局部变量都会拷贝一份到lambda表达式的实体中，然后在lambda表达式里要变也只能变自己拷贝的那份，而无法影响外部原本的变量，所以Java语言的设计者就干脆禁止捕获可变局部变量。

其二，Java 8可以写出并行代码。其中`forEach`是并行的，这样写的代码没有写竞争条件，让lambda体执行起来相当困难。除非我们愿意（最好是在编译时）强制执行这样一个函数而无法逃脱其捕获线程，否则此功能很可能会引起更多的麻烦。

------

总结一下，在Java中，Lambda表达式有其相应的函数式接口，再有类型推断机制的辅助作用，使用起来更加方便。

------

项目总结。

我们研究了$\lambda$演算还有C++和Java中的lambda表达式。